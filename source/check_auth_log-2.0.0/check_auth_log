#!/usr/bin/php -q
<?php
// check_auth_log
//
// Prevent malicious use of stolen email credentials to send large 
// volumes of email through a postfix mail server. This program parses
// sasl authentication info from postifx log file and if configurable 
// limits are exceeded blocks further sending.
//
// For installation instructions see file INSTALL.
// For usage instructions see file USAGE.
// For licensing see file LICENSE.
// 
// Copyright 2010-2014 John Fawcett (john at emailsupport.it)
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
$version='2.0.0';
$debug=false;

$opts=getopt('a:c:d:vtxy');

// check_auth_log -v
if (isset($opts['v']))
{
	echo 'check_auth_log version '.$version."\n".'Copyright 2010-2014 John Fawcett (john at emailsupport.it)'."\n".'Released under GPL v.3. There is no warranty'."\n\n";
	exit;
}

// check_auth_log -t
if (isset($opts['t']))
{
	echo 'check_auth_log version '.$version."\n".'Copyright 2010-2014 John Fawcett (john at emailsupport.it)'."\n".'Released under GPL v.3. There is no warranty'."\n";
	echo 'option t found, activating tracing'."\n";
	$debug=true;
}

// check_auth_log -c<config_file>
// override default config file setting /etc/check_auth_log.conf
$configfile='';
if (isset($opts['c']))
{
	$configfile=$opts['c'];
}
$conf = read_config($configfile);

// check_auth_log -d <saslusername>
// this re-enables mail sending
// If blocking method is access, then the saslusername is removed
// from the access file. If immediate activitation is required 
// the access file should be postmapped and postfix reloaded
// If blocking method is mysql, then executes the unblock query.

if (isset($opts['d']))
{
	$cached_vars=initialize($conf);
	$cached_vars=open_db($conf,$cached_vars,'dbfile','rw');
	switch($conf['block_type'])
	{
		case 'test':
			break;
		case 'mysql':
			update_user_mysql($conf,$opts['d'],'unblock');
			break;
		case 'exim':
			delete_exim_record($conf,$opts['d']);
			break;
		case 'access':
		default:
			delete_access_record($conf,$opts['d']);
			break;
	}
	delete_db_record($conf,$cached_vars,$opts['d']);
	exit;
}

// check_auth_log -a <saslusername>
// this blockss mail sending
// If blocking method is access, then the saslusername is added to
// the access file. If immediate blocking is required 
// the access file should be postmapped and postfix reloaded
// If blocking method is mysql, then executes the block query.

if (isset($opts['a']))
{
        $cached_vars=initialize($conf);
        $cached_vars=open_db($conf,$cached_vars,'dbfile','rw');
        switch($conf['block_type'])
        {
                case 'test':
                        break;
                case 'mysql':
                        update_user_mysql($conf,$opts['a'],'block');
                        break;
                case 'exim':
                        add_exim_record($conf,$opts['a']);
                        break;
                case 'access':
                default:
                        add_access_record($conf,$opts['a']);
                        break;
        }
        exit;
}

// check_auth_log -x
// extract database entries and print to standard output

if (isset($opts['x']))
{
	$cached_vars=initialize($conf);
	$cached_vars=open_db($conf,$cached_vars,'dbfile','r');
	extract_db($conf,$cached_vars,'dbfile');
	close_db($conf,$cached_vars,'dbfile');
	exit;
}

// check_auth_log -y
// extract cachefile entries and print to standard output

if (isset($opts['y']))
{
	$cached_vars=initialize($conf);
	$cached_vars=open_db($conf,$cached_vars,'cachefile','r');
	extract_db($conf,$cached_vars,'cachefile');
	close_db($conf,$cached_vars,'cachefile');
	exit;
}

// if no -a -d -x -y option then do a normal run

$cached_vars=initialize($conf);
$cached_vars=open_db($conf,$cached_vars,'dbfile','rw');
$cached_vars=open_db($conf,$cached_vars,'cachefile','rw');
$cached_vars=locate_next_line($conf,$cached_vars,'log');
$cached_vars=process_rotated_log($conf,$cached_vars,'log');
$cached_vars=process_log($conf,$cached_vars,'log');
save_position($conf,$cached_vars,'log');
if ($conf['popfile'] !='')
{
	$cached_vars=locate_next_line($conf,$cached_vars,'pop');
	$cached_vars=process_rotated_log($conf,$cached_vars,'pop');
	$cached_vars=process_log($conf,$cached_vars,'pop');
	save_position($conf,$cached_vars,'pop');
}
close_log($conf,$cached_vars);
close_db($conf,$cached_vars,'dbfile');
close_db($conf,$cached_vars,'cachefile');

// set the configuration parameters.

function read_config($configfile)
{
	global $debug;
	if ($debug) echo 'start read_config'."\n";
	if ($configfile=='')
		$conf['configfile']='/etc/check_auth_log.conf';
	else
		$conf['configfile']=$configfile;

// read config file
	$ini=parse_ini_file($conf['configfile']);

	$defaults=array(
		'mta'=>'postfix',
		'logfile'=>'/var/log/mail.log',
		'logfile_rotated'=>'',
		'popfile'=>'',
		'popfile_rotated'=>'',
		'cachefile'=>'/tmp/.check_auth_log_cache_db',
		'dbfile'=>'/tmp/.check_auth_log_db',
		'dbtype'=>'db4',
		'expire'=>3600,
		'auth_limit'=>100,
		'ip_limit'=>3,
		'max_auth_records'=>200,
		'posix'=>true,
		'stale_lock_time'=>300,
		'block_type'=>'mysql',
		'sql_connect'=>'',
		'sql_block'=>'',
		'sql_unblock'=>'',
		'accessfile'=>'/etc/postfix/smtp_auth_access.in',
		'exim_block_file'=>'/tmp/blocklist',
		'exim_temp_file'=>'/tmp/blocklist.out',
		'reject_msg'=>'REJECT send quota exceeded. Contact support to re-enable');

	foreach($ini as $k=>$v)
	{
		if ($debug)
			echo "Ini file read $k value $v\n";
		if (!isset($defaults[$k])) echo 'Warning ignoring unknown configuration setting '.$k."\n";
	}

// set config values to ini values if present else defaults
	foreach($defaults as $k=>$d)
	{
		if ($debug) echo 'Variable '.$k.' default '.$d.' using ';	
		if (isset($ini[$k])) $conf[$k]=$ini[$k]; else $conf[$k]=$d;
		if ($debug) echo $conf[$k]."\n";
	}
	return $conf;
}

// setup some variables used within the script and check for dba support or config errors

function initialize($conf)
{
	global $debug;
	if ($debug) echo 'start initalize'."\n";
	$cached_vars['ref_ts']=time();	
	$cached_vars['access_changes']=false;
	$cached_vars['rotated']=false;
	$found=false;
	if (!function_exists('dba_handlers')) die('This program requires the dba_handlers function from the php DBA extension. It may be in a package like php-dba. Please refer to the manual for your operating system distribution.');
	if ($conf['posix'] != true && $conf['posix'] != false) die('Invalid posix value of  '.$conf['posix'].'. Value must be true or false'."\n");
	if ($conf['posix'] && !function_exists('posix_kill')) die('This program requires the posix_kill function from the php posix extension. It may be in a package like php-process. Please refer to the manual for your operating system distribution. If you prefer you may disable posix code (used within pid locking) by setting configuration variable posix = false');
	foreach (dba_handlers() as $handler_name => $handler_version)
	{
		if ($conf['dbtype']==$handler_name) $found=true;
	}
	if (!$found) die ('no support for db type '.$conf['dbtype']."\n");
	if ($conf['auth_limit'] > $conf['max_auth_records']) die ('cannot set auth_limit higher than max_auth_records'."\n");
	if ($conf['ip_limit'] > $conf['max_auth_records']) die ('cannot set ip_limit higher than max_auth_records'."\n");
	if ($conf['block_type'] !='mysql' && $conf['block_type'] !='access' && $conf['block_type'] !='exim' && $conf['block_type'] !='test') die('unknown value '.$conf['block_type'].'for block_type'."\n");
	if ($conf['block_type'] =='mysql' && ($conf['sql_connect']==''|| $conf['sql_block']==''||$conf['sql_unblock']=='')) die('set values for all of sql_connect sql_block and sql_unblock when block_type is mysql'."\n");
	if ($conf['block_type']=='exim' && !is_readable($conf['exim_block_file'])) die('Block file '.$conf['exim_block_file'].' is not readable');
	if ($conf['block_type']=='exim' && !is_writeable($conf['exim_block_file'])) die('Block file '.$conf['exim_block_file'].' is not writeable');
	if ($conf['block_type']=='access' && $conf['accessfile']=='') die('accessfile '.$conf['accessfile'].' cannot be blank');
	if ($conf['block_type']=='exim' && $conf['exim_temp_file']=='') die('exim_temp_file '.$conf['exim_temp_file'].' cannot be blank');
	if ($conf['mta'] !='postfix' && $conf['mta'] !='exim') die('unknown value '.$conf['mta'].'for mta'."\n");
	if ($conf['stale_lock_time'] < 0) die('Invalid stale_lock_time of '.$conf['stale_lock_time'].'. Value must be >= 0'."\n");
	return $cached_vars;
}

// open database used to store info of email authentications

function open_db($conf,$cached_vars,$db,$mode)
{
	global $debug;
	$open_mode='cd';
	if ($mode=='rw') $open_mode='cdt';
	if ($mode=='r') $open_mode='rdt';
	if ($debug) echo 'start open_db '.$db.' '.$conf[$db]."\n";
	if (!$dbh = dba_open($conf[$db],$open_mode,$conf['dbtype']))
	{
		echo 'could not open database '.$conf[$db].' of type '.$conf['dbtype']."\n";
		echo "Available DBA handlers:\n";
		foreach (dba_handlers(true) as $handler_name => $handler_version)
		{
			$handler_version = str_replace('$', '', $handler_version);
			echo "- $handler_name: $handler_version\n";
		}
		exit;
	}
	$cached_vars['dbh_'.$db]=$dbh;
	if ($debug) echo 'db opened '.$db.' '.$conf[$db]."\n";
	return $cached_vars;
}


// open log file and position file pointer at next unread line

function locate_next_line($conf,$cached_vars,$log)
{
	global $debug;
	if ($debug) echo 'start locate_next_line for '.$log."\n";
	$cached_vars['rotated']=false;
	$log_fh=fopen($conf[$log.'file'],'r') or die('could not open file '.$conf[$log.'file']."\n");
	$firstline=fgets($log_fh);
	$cached_vars[$log.'_fh']=$log_fh;
	$cached_vars[$log.'_firstline']=$firstline;

// no previous cache file pos, set log stream position to start of log

	$stored_firstline=dba_fetch($log.'_firstline',$cached_vars['dbh_cachefile']);
	$stored_lastline=dba_fetch($log.'_lastline',$cached_vars['dbh_cachefile']);
	$stored_pos=dba_fetch($log.'_pos',$cached_vars['dbh_cachefile']);
	if(!$stored_pos || !$stored_lastline || !$stored_firstline)
	{
		$rc=fseek($log_fh,0);
		if ($rc != 0) die ('error positioning at start of log'."\n");
		return $cached_vars;	
	}

// no match with stored first line, the file is likely rotated

	if ($firstline != $stored_firstline && $stored_firstline !='')
	{
		if ($conf[$log.'file_rotated']!='')
		{
			$conf=update_rotated_logfile_name($conf,$log);
			$log_fh_rot=fopen($conf[$log.'file_rotated'],'r') or die('could not open file '.$conf[$log.'file_rotated']."\n");

			// set rotated log stream to last processed line

			$offset=strlen($stored_lastline);
			$pos=intval($stored_pos)-$offset;
			$rc=fseek($log_fh_rot,$pos);
			if ($rc != 0) die ('error positioning at ['.$pos.'] in rotated log'."\n");
			$lastline=fgets($log_fh_rot);
			if ($lastline!==false && $lastline == $stored_lastline)
			{
				$cached_vars[$log.'_fh_rot']=$log_fh_rot;
				$cached_vars['rotated']=true;
			}
		}

		// set log stream position to start of log

		$rc=fseek($log_fh,0);
		if ($rc != 0) die ('error positioning at start of log'."\n");
		return $cached_vars;	
	}

// set log stream to last processed line

	$offset=strlen($stored_lastline);
	$pos=intval($stored_pos)-$offset;
	$rc=fseek($log_fh,$pos);
	if ($rc != 0) die ('error positioning at ['.$pos.'] in log'."\n");
	$lastline=fgets($log_fh);
	if ($lastline===false || $lastline != $stored_lastline)
	{
		$rc=fseek($log_fh,0);
		if ($rc != 0) die ('error positioning at start of log'."\n");
		return $cached_vars;	
	}
	return $cached_vars;
}

// substitute variables in log file name

function update_rotated_logfile_name($conf,$log)
{
	if (strpos($conf[$log.'file_rotated'],'YYYY')===FALSE)
	{
		$conf[$log.'file_rotated']=str_replace('YY',date('y'),$conf[$log.'file_rotated']);
	}
	else
	{
		$conf[$log.'file_rotated']=str_replace('YYYY',date('Y'),$conf[$log.'file_rotated']);
	}

	$conf[$log.'file_rotated']=str_replace('MM',date('m'),$conf[$log.'file_rotated']);
	$conf[$log.'file_rotated']=str_replace('DD',date('d'),$conf[$log.'file_rotated']);
	return $conf;
}


// process the log lines from current position to end of file

function process_log($conf,$cached_vars,$log)
{
	global $debug;
	if ($debug) echo 'start process_log for '.$log."\n";
	$i=0;
	while (!feof($cached_vars[$log.'_fh']))
	{
		$line = fgets($cached_vars[$log.'_fh']);
		if ($line !== false)
		{
			$cached_vars[$log.'_lastline']=$line;
			$cached_vars=process_line($conf,$cached_vars,$line,$log);
			$i++;
		}
	}
	$cached_vars['lines_read']=$i;
	return $cached_vars;
}

// process the rotated log if needed 

function process_rotated_log($conf,$cached_vars,$log)
{
	global $debug;
	if ($debug) echo 'start process_rotated_log for '.$log."\n";
	if (!$cached_vars['rotated'])
		return $cached_vars;
	$i=0;
	while (!feof($cached_vars[$log.'_fh_rot']))
	{
		$line = fgets($cached_vars[$log.'_fh_rot']);
		if ($line !== false)
		{
			$cached_vars=process_line($conf,$cached_vars,$line,$log);
			$i++;
		}
	}
	return $cached_vars;
}

// save info about last log position to cache file 

function save_position($conf,$cached_vars,$log)
{
	global $debug;
	if ($debug) echo 'start save_position for '.$log."\n";
	if ($cached_vars['lines_read']==0 && !$cached_vars['rotated']) return;
	$pos=ftell($cached_vars[$log.'_fh']);
	if (!isset($cached_vars[$log.'_lastline'])) $cached_vars[$log.'_lastline']='';
	dba_replace($log.'_firstline',$cached_vars[$log.'_firstline'],$cached_vars['dbh_cachefile']) or die('cannot insert into db, key: '.$log.'_firstline'."\n");
	dba_replace($log.'_lastline',$cached_vars[$log.'_lastline'],$cached_vars['dbh_cachefile']) or die('cannot insert into db, key: '.$log.'_lastline'."\n");
	dba_replace($log.'_pos',$pos,$cached_vars['dbh_cachefile']) or die('cannot insert into db, key: '.$log.'_pos'."\n");
}

// close log 

function close_log($conf,$cached_vars)
{
	fclose($cached_vars['log_fh']);
}

// close db 

function close_db($conf,$cached_vars,$db)
{
	dba_close($cached_vars['dbh_'.$db]);
}

// parse single log line, if it contains sasl authentication update database record and if limits exceeded apply block

function process_line($conf,$cached_vars,$line,$log)
{
        global $debug;
	list($rc,$ip,$login,$unix_ts)=match_line($conf,$cached_vars,$line,$log);
	if ($debug)
	{
		if ($rc)
			echo "Found ip $ip, login $login, ts $unix_ts\n";
		else
			echo "Not found\n";
	}
	if($rc)
	{
		$cur_val=dba_fetch($login,$cached_vars['dbh_dbfile']);
		if ($cur_val === false)
		{
			$new_val= $ip.','.$unix_ts.';';	
			$new_val=remove_expired($conf,$cached_vars,$new_val);
			dba_insert($login,$new_val,$cached_vars['dbh_dbfile']) or die('cannot insert into db, key: '.$login."\n");
		}
		else
		{
			$new_val= $cur_val.$ip.','.$unix_ts.';';	
			$new_val=remove_expired($conf,$cached_vars,$new_val);
			dba_replace($login,$new_val,$cached_vars['dbh_dbfile']) or die('cannot insert into db, key: '.$login."\n");
		}
		$cached_vars=check_limit($conf,$cached_vars,$login,$new_val);
	}
	return $cached_vars;
}

// parsing of the log lines delegated to this function in order to better manage support for multiple mtas

function match_line($conf,$cached_vars,$line,$log)
{
        global $debug;
        if ($debug) echo 'processing log line: '.$line."\n";
	if ($log=='log')
        {
		$ts_pos=1;
		$ip_pos=2;
		$login_pos=3;
	        switch($conf['mta'])
	        {
        	        case 'exim':
               	        	$pattern='/^(\d+-\d+-\d+ \d+\:\d+\:\d+).*H=.* \[(\d+\.\d+\.\d+\.\d+)\] P=\w+.*A=\w+\:(\S*)/';
                   		break;
                	case 'postfix':
                	default:
                        	$pattern='/^(\S*\s*\S*\s*\S*)\s\S*\s\S*\s\S*\sclient=[^\[]*\[(\S*)\], sasl_method=\S*, sasl_username=(\S*)/';
                        	break;
        	}
        }
	if ($log=='pop')
        {
		$ts_pos=1;
		$ip_pos=3;
		$login_pos=2;
		$pattern='/^(\S*\s*\S*\s*\S*).*pop3-login: Login: user=<(\S*)>.*rip=(\d+\.\d+\.\d+\.\d+)/';
        }
        $rc= preg_match($pattern, $line, $matches);
        if($rc != 0)
        {
                $ip=$matches[$ip_pos];
                $login=$matches[$login_pos];
                if ($conf['mta']=='exim')
                {
                        $dt = $matches[$ts_pos];
                }
                if ($conf['mta']=='postfix'||$log='pop')
                {
                        $ts=str_replace('  ',' ',$matches[$ts_pos]);
                        list($month,$day,$ts_time) = explode(' ',$ts);
                        $year = date('Y');
                        list($hour,$min,$sec) = explode(':',$ts_time);
                        $dt = $day.'-'.$month.'-'.$year.' '.$ts_time;
                }
                if (($unix_ts = strtotime($dt)) === false)
                {
                        die ('unable to convert string to timestamp '.$dt.' (timestamp was: '.$ts.')'."\n");
                }
                return array(true,$ip,$login,$unix_ts);
        }
        return array(false,'','','');
}


// removes old authentication record

function remove_expired($conf,$cached_vars,$cur_val)
{
	if ($cur_val=='') return '';
	$new_val='';
	$vals=explode(';',$cur_val);
	if (count($vals) >= $conf['max_auth_records'])
	{
		array_shift($vals);
	}
	foreach($vals as $val)
	{
		if ($val != '')
		{
			list($ip,$unix_ts) = explode(',',$val);
			if ($unix_ts+$conf['expire'] > $cached_vars['ref_ts']) $new_val.=$val.';';	
		}
	}
	return $new_val;
}

// Checks if limits exceeded and applies block to username

function check_limit($conf,$cached_vars,$login,$new_val)
{
	if ($new_val=='') return $cached_vars;
	$ips=array();
	$vals=explode(';',$new_val);
	foreach($vals as $val)
	{
		if ($val != '')
		{
			list($ip,$unix_ts) = explode(',',$val);
			$ips[]=$ip;
		}
	}
	if (count($ips) ==0) return $cached_vars;
	$unique_ips=array_unique($ips);
	if (($conf['auth_limit'] != 0 && count($vals) > $conf['auth_limit']) || ($conf['ip_limit'] !=0 && count($unique_ips)> $conf['ip_limit']))
	{
		switch($conf['block_type'])
		{
			case 'test':
				break;
			case 'mysql':
				update_user_mysql($conf,$login,'block');
				break;
			case 'exim':
				add_exim_record($conf,$login);
				break;
			case 'access':
			default:
				add_access_record($conf,$login);
				break;
		}
		$cached_vars['access_changes']=true;
	}
	return $cached_vars;
}

// add postfix access record

function add_access_record($conf,$key)
{
	if(!is_readable($conf['accessfile']))
		file_put_contents($conf['accessfile'],'');
	$in=file($conf['accessfile']);
	$imax=count($in);
	$i=0;
	$found=false;
	while($i<$imax)	
	{
		$r=explode(' ',$in[$i]);
		if($r[0]==$key)
		{
			$found=true;
			$i=$imax;	
		}
		$i++;
	}
	if (!$found) 
        {
		$in[]=$key.' '.$conf['reject_msg']."\n";
		file_put_contents($conf['accessfile'],implode('',$in));
		echo 'Added '.$key.' to '.$conf['accessfile']."\n";
	}
	else
        {
		echo 'Add failed: '.$key.' already in '.$conf['accessfile']."\n";
	}
}

// block user in mysql

function update_user_mysql($conf,$key,$mode)
{
        $url=parse_url($conf['sql_connect']);
        if ($url !== false && isset($url['scheme']) && $url['scheme']=='mysql')
        {
                if (isset($url['host']) && $url['host'] != '') $host=$url['host']; else die('No database hostname specified in url'."\n");
                if (isset($url['port']) && $url['port'] != '') $host .= ':'.$url['port'];
                if (isset($url['user']) && $url['user'] != '') $user=$url['user']; else die('No database user specified in url'."\n");
                if (isset($url['pass']) && $url['pass'] != '') $password=$url['pass']; else die('No database password specified in url'."\n");
                if (isset($url['path']) && $url['path'] != '') $database=substr($url['path'],1); else die('No database password specified in url'."\n");
		if ($mode=='block') 
			$query = $conf['sql_block'];
		else
			$query = $conf['sql_unblock'];

                $query = str_replace('%u', $key, $query);

                $connection = mysql_connect($host,$user,$password)
                or die('Could not connect: '.mysql_error()."\n");

                mysql_select_db($database,$connection)
                or die('Error in selecting the database: '.mysql_error()."\n");

                $sql_result=mysql_query($query,$connection)
                or die('Sql Error '.mysql_error());
		if(mysql_affected_rows($connection) == 1)
        	{
			if ($mode=='block')
				echo 'Disabled '.$key.' in mysql database'."\n";
			else
				echo 'Enabled '.$key.' in mysql database'."\n";
		}
	}
	else
        {
		die('could not parse sql connect string '.$conf['sql_connect']."\n");	
	}
}

// add exim block record

function add_exim_record($conf,$key)
{
	$in=file($conf['exim_block_file']);
	$imax=count($in);
	$i=0;
	$found=false;
	while($i<$imax)	
	{
		$r=explode(' ',$in[$i]);
		if($r[0]==$key)
		{
			$found=true;
			$i=$imax;	
		}
		$i++;
	}
	if (!$found) 
        {
		$in[]=$key."\n";
		file_put_contents($conf['exim_temp_file'],implode('',$in));
		$rc=rename($conf['exim_temp_file'],$conf['exim_block_file']);
		if ($rc===false)
			echo 'Failed to rename '.$conf['exim_temp_file'].' to '.$conf['exim_block_file']."\n";
		else
			echo 'Added '.$key.' to '.$conf['exim_block_file']."\n";
	}
	else
        {
		echo 'Add failed: '.$key.' already in '.$conf['exim_block_file']."\n";
	}
}

// delete postfix access record

function delete_access_record($conf,$key)
{
	if(!is_readable($conf['accessfile'])) die("cannot open access file ".$conf['accessfile']."\n");
	$in=file($conf['accessfile']);
	$imax=count($in);
	$i=0;
	$out=array();
	$found=false;
	while($i<$imax)	
	{
		$r=explode(' ',$in[$i]);
		if($r[0]!=$key)
		{
			$out[]=$in[$i];
		}
		else
		{
			$found=true;
		}
		$i++;
	}
	if ($found)
	{
		if (count($out)==0) $outstr=''; else $outstr=implode('',$out);
		file_put_contents($conf['accessfile'],$outstr);
		echo 'Removed '.$key.' from '.$conf['accessfile']."\n";
	}
	else
	{
		echo 'Removal failed: '.$key.' not in '.$conf['accessfile']."\n";
	}
}

// delete exim record

function delete_exim_record($conf,$key)
{
	if(!is_readable($conf['exim_block_file'])) die("cannot open exim block file ".$conf['exim_block_file']."\n");
	$in=file($conf['exim_block_file']);
	$imax=count($in);
	$i=0;
	$out=array();
	$found=false;
	while($i<$imax)	
	{
		$r=trim($in[$i]);
		if($r!=$key)
		{
			$out[]=$in[$i];
		}
		else
		{
			$found=true;
		}
		$i++;
	}
	if ($found)
	{
		if (count($out)==0) $outstr=''; else $outstr=implode('',$out);
		file_put_contents($conf['exim_temp_file'],$outstr);
		$rc=rename($conf['exim_temp_file'],$conf['exim_block_file']);
		if ($rc===false)
			echo 'Failed to rename '.$conf['exim_temp_file'].' to '.$conf['exim_block_file']."\n";
		else
			echo 'Removed '.$key.' from '.$conf['exim_block_file']."\n";
	}
	else
	{
		echo 'Removal failed: '.$key.' not in '.$conf['exim_block_file']."\n";
	}
}

// delete db record

function delete_db_record($conf,$cached_vars,$key)
{
	if (dba_delete($key,$cached_vars['dbh_dbfile']))
		echo 'Removed '.$key.' from '.$conf['dbfile']."\n";
	dba_optimize($cached_vars['dbh_dbfile']);;
}
// extract all db records

function extract_db($conf,$cached_vars,$db)
{
	global $debug;
	if ($debug) echo 'start extract_db'."\n";
	for($k = dba_firstkey($cached_vars['dbh_'.$db]); $k != false; $k = dba_nextkey($cached_vars['dbh_'.$db]))
	{
		if ($db=='dbfile')
		{
       	 		echo 'login: '.$k."\n";
			$auth_sessions = dba_fetch($k, $cached_vars['dbh_'.$db]);
			$vals=explode(';',$auth_sessions);
			foreach($vals as $val)
			{
				if ($val != '')
				{
					list($ip,$unix_ts) = explode(',',$val);
					echo "\t".'ip: '.$ip.' time: '.date('Y-m-d H:i:s',$unix_ts)."\n";
				}
			}
		}
		if ($db=='cachefile')
		{
			$v = dba_fetch($k, $cached_vars['dbh_'.$db]);
			echo "key $k value $v\n";
		}
	}
}

function get_lock($conf,$cached_vars)
{
	$lock_pid=dba_fetch('lock_pid',$cached_vars['dbh_cachefile']);
	if ($lock_pid!='')	
	{
		if ($conf['posix'])
		{
			if (posix_kill($lock_pid,0)) die('Only one instance of check_auth_log may be active. There is an existing lock and the process is still running. Pid of other process is '.$lock_pid.'. Exiting');
		}
		else
		{
			$lock_time=dba_fetch('lock_time',$cached_vars['dbh_cachefile']);
			if (time()-$lock_time < $conf['stale_lock_time']) die('Only one instance of check_auth_log may be active. There is an existing lock and stale_lock_time has not been passed. Pid of other process is '.$lock_pid.'. Exiting');
		}
	}
	$mypid=getmypid();
	dba_replace('lock_pid',$mypid,$cached_vars['dbh_cachefile']);	
	dba_replace('lock_time',time(),$cached_vars['dbh_cachefile']);	
	$new_lock_pid=dba_fetch('lock_pid',$cached_vars['dbh_cachefile']);
	if ($new_lock_pid!=$mypid) die('Only one instance of check_auth_log may be active. Another process has obtained the lock. Pid of other process is '.$new_lock_pid.'. Exiting');
	return $cached_vars;
}

function release_lock($conf,$cached_vars)
{
	dba_replace('lock_pid','',$cached_vars['dbh_cachefile']);	
	dba_replace('lock_time',0,$cached_vars['dbh_cachefile']);	
	return $cached_vars;
}

